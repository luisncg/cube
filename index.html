<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple P2P Multiplayer Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #fpsCounter {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
        }
        #playerList {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>
            <input id="playerName" type="text" placeholder="Your name" maxlength="10">
            <button id="hostGame">Host Game</button>
            <button id="joinGame">Join Game</button>
            <input id="roomId" type="text" placeholder="Room ID to join" style="display:none;">
        </div>
        <div id="roomInfo" style="display:none;">
            <p>Room ID: <span id="currentRoomId"></span></p>
            <p>Connected players: <span id="playerCount">1</span></p>
        </div>
        <div id="playerList"></div>
        <div id="controls" style="margin-top: 10px;">
            <p>Controls: WASD to move, Mouse to look around</p>
        </div>
        <div style="margin-top: 10px;">
            <label for="qualitySelect">Graphics Quality:</label>
            <select id="qualitySelect">
                <option value="high">High</option>
                <option value="medium" selected>Medium</option>
                <option value="low">Low</option>
            </select>
        </div>
    </div>
    
    <div id="fpsCounter">FPS: 0</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>

    <script>
        // Main game variables
        let camera, scene, renderer;
        let localPlayer, players = {};
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let peer, connections = [];
        let playerId, roomId;
        let playerName = "";
        let playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        
        // Time tracking for frame-independent movement
        let lastTime = null;
        
        // FPS counter variables
        let fpsCounter;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Performance settings
        let qualitySettings = {
            high: {
                antialias: true,
                objectCount: 20,
                objectDetail: 16,
                drawDistance: 1000,
                shadowsEnabled: true
            },
            medium: {
                antialias: true,
                objectCount: 10,
                objectDetail: 8,
                drawDistance: 500,
                shadowsEnabled: false
            },
            low: {
                antialias: false,
                objectCount: 5,
                objectDetail: 6,
                drawDistance: 300,
                shadowsEnabled: false
            }
        };
        let currentQuality = 'medium';
        let worldObjects = [];

        // Initialize the game
        function init() {
            // Set up Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // Average eye height
            
            // Get quality selector
            const qualitySelect = document.getElementById('qualitySelect');
            qualitySelect.addEventListener('change', function() {
                currentQuality = this.value;
                updateQuality();
            });
            
            // Set initial quality from select element
            currentQuality = qualitySelect.value;
            
            // Create renderer with quality settings
            updateRenderer();
            
            // Setup FPS counter
            fpsCounter = document.getElementById('fpsCounter');
            
            // Create world objects based on quality settings
            createWorld();
            
            // Create local player
            createLocalPlayer();
            
            // Set up controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            // Lock pointer for mouse controls
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            lastTime = performance.now() * 0.001;
            animate();
        }
        
        function updateRenderer() {
            // Remove old renderer if it exists
            if (renderer && renderer.domElement) {
                document.body.removeChild(renderer.domElement);
            }
            
            // Create new renderer with current quality settings
            const settings = qualitySettings[currentQuality];
            renderer = new THREE.WebGLRenderer({ 
                antialias: settings.antialias,
                precision: currentQuality === 'low' ? 'lowp' : 'mediump',
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(currentQuality === 'low' ? 0.8 : window.devicePixelRatio);
            
            // Update camera far plane
            camera.far = settings.drawDistance;
            camera.updateProjectionMatrix();
            
            document.body.appendChild(renderer.domElement);
            
            // Re-add pointer lock event listener to the new renderer
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
        }
        
        function updateQuality() {
            updateRenderer();
            
            // Clear existing world objects
            worldObjects.forEach(obj => scene.remove(obj));
            worldObjects = [];
            
            // Recreate world with new settings
            createWorld();
            
            // If the local player exists, recreate it
            if (localPlayer) {
                scene.remove(localPlayer);
                createLocalPlayer();
            }
        }
        
        function createWorld() {
            const settings = qualitySettings[currentQuality];
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            
            if (settings.shadowsEnabled) {
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                renderer.shadowMap.enabled = true;
            }
            
            scene.add(directionalLight);
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2e8b57,  // Sea green
                side: THREE.DoubleSide,
                flatShading: currentQuality === 'low'
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            
            if (settings.shadowsEnabled) {
                ground.receiveShadow = true;
            }
            
            scene.add(ground);
            worldObjects.push(ground);
            
            // Add random objects based on quality setting
            for (let i = 0; i < settings.objectCount; i++) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff,
                    flatShading: currentQuality === 'low'
                });
                const cube = new THREE.Mesh(geometry, material);
                
                // Random position
                cube.position.x = (Math.random() - 0.5) * 50;
                cube.position.z = (Math.random() - 0.5) * 50;
                cube.position.y = 0.5;
                
                if (settings.shadowsEnabled) {
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                }
                
                scene.add(cube);
                worldObjects.push(cube);
            }
            
            // Recreate remote players if they exist
            Object.keys(players).forEach(id => {
                if (!players[id]) return;
                
                try {
                    const pos = players[id].position.clone();
                    const rot = players[id].rotation.clone();
                    const name = players[id].userData?.name || "Player";
                    
                    scene.remove(players[id]);
                    
                    // Recreate player
                    const geometry = new THREE.BoxGeometry(1, 1, 1); // Cube instead of sphere
                    const colorIndex = Object.keys(players).indexOf(id) % playerColors.length + 1;
                    const material = new THREE.MeshStandardMaterial({ 
                        color: playerColors[colorIndex],
                        flatShading: currentQuality === 'low'
                    });
                    
                    const playerMesh = new THREE.Mesh(geometry, material);
                    playerMesh.position.copy(pos);
                    playerMesh.rotation.copy(rot);
                    playerMesh.userData = { name: name };
                    
                    scene.add(playerMesh);
                    players[id] = playerMesh;
                    
                    // Create player label
                    createPlayerLabel(playerMesh, name);
                } catch (e) {
                    console.error("Error recreating player:", e);
                }
            });
        }
        
        // Create local player
        function createLocalPlayer() {
            const settings = qualitySettings[currentQuality];
            const geometry = new THREE.BoxGeometry(1, 1, 1); // Cube instead of sphere
            const material = new THREE.MeshStandardMaterial({ 
                color: playerColors[0],
                flatShading: currentQuality === 'low'
            });
            localPlayer = new THREE.Mesh(geometry, material);
            localPlayer.position.y = 0.5;
            
            if (settings.shadowsEnabled) {
                localPlayer.castShadow = true;
            }
            
            scene.add(localPlayer);
            
            // Create a label for the player name
            createPlayerLabel(localPlayer, playerName || "You");
        }
        
        // Create a text label for a player
        function createPlayerLabel(playerMesh, name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.5)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.fillText(name, canvas.width / 2, canvas.height / 2 + 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.y = 1.2;
            sprite.scale.set(2, 0.5, 1);
            
            playerMesh.add(sprite);
            return sprite;
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle keyboard input
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        // Handle mouse movement for camera rotation
        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                // Rotate the player based on mouse movement
                const movementX = event.movementX || 0;
                
                localPlayer.rotation.y -= movementX * 0.002;
                
                // Update camera position relative to player
                updateCameraPosition();
            }
        }
        
        // Update camera position relative to player
        function updateCameraPosition() {
            if (!localPlayer) return;
            
            // Position camera right behind the player (increased distance from 2 to 4)
            const offset = new THREE.Vector3(0, 2.5, 5);
            offset.applyQuaternion(localPlayer.quaternion);
            offset.add(localPlayer.position);
            
            camera.position.copy(offset);
            
            // Look at point slightly above player
            const target = new THREE.Vector3(0, 0.8, -3);
            target.applyQuaternion(localPlayer.quaternion);
            target.add(localPlayer.position);
            
            camera.lookAt(target);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate time delta for consistent movement
            const currentTime = performance.now() * 0.001; // seconds
            const deltaTime = Math.min(0.1, currentTime - lastTime); // Cap delta at 0.1 seconds
            lastTime = currentTime;
            
            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1.0) { // Update every second
                fpsCounter.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Process player movement
            if (moveForward || moveBackward || moveLeft || moveRight) {
                // Fixed movement speed (units per second)
                const speed = 5.0;
                
                // Calculate movement direction
                direction.x = 0;
                direction.z = 0;
                
                if (moveForward) direction.z -= 1;
                if (moveBackward) direction.z += 1;
                if (moveLeft) direction.x -= 1;
                if (moveRight) direction.x += 1;
                
                if (direction.x !== 0 || direction.z !== 0) {
                    // Normalize the direction vector
                    direction.normalize();
                    
                    // Calculate movement with delta time
                    const movementVector = new THREE.Vector3(
                        direction.x * speed * deltaTime,
                        0,
                        direction.z * speed * deltaTime
                    );
                    
                    // Apply player's rotation to movement
                    movementVector.applyQuaternion(localPlayer.quaternion);
                    
                    // Update player position
                    localPlayer.position.add(movementVector);
                    
                    // Send position to peers
                    sendPositionUpdate();
                    
                    // Update camera after moving
                    updateCameraPosition();
                }
            }
            
            // Only skip rendering on low quality, not movement calculations
            if (currentQuality === 'low' && frameCount % 2 === 0) {
                return;
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // P2P Connection Setup
        function setupPeerConnection() {
            // Generate a simple random ID (no prefix needed)
            playerId = Math.floor(Math.random() * 1000000).toString();
            
            // Initialize PeerJS with a reliable public server
            peer = new Peer(playerId, {
                debug: 2,
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                playerId = id;
            });
            
            peer.on('connection', (conn) => {
                handleConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                
                if (err.type === 'peer-unavailable') {
                    alert('Could not connect to the specified room. Please check the Room ID and try again.');
                } else if (err.type === 'network' || err.type === 'disconnected') {
                    alert('Network error. Please check your internet connection and try again.');
                } else if (err.type === 'server-error') {
                    alert('PeerJS server error. Please try again later.');
                } else {
                    alert('Connection error: ' + err);
                }
                
                // Reset UI on error to allow trying again
                hostButton.disabled = false;
                joinButton.disabled = false;
                roomIdInput.disabled = false;
                playerNameInput.disabled = false;
            });
        }
        
        // Host a new game
        function hostGame() {
            playerName = playerNameInput.value || "Host";
            setupPeerConnection();
            
            peer.on('open', (id) => {
                // Use the actual peer ID as the room ID to ensure consistency
                roomId = id;
                
                // Update UI
                hostButton.disabled = true;
                joinButton.disabled = true;
                playerNameInput.disabled = true;
                roomInfo.style.display = 'block';
                currentRoomIdSpan.textContent = roomId;
                
                // Add host to player list
                updatePlayerList({
                    id: playerId,
                    name: playerName,
                    host: true
                });
                
                console.log('Game hosted! Room ID:', roomId);
                alert('Game created! Share this Room ID with others: ' + roomId);
            });
        }
        
        // Join an existing game
        function joinGame() {
            if (roomIdInput.style.display === 'none') {
                roomIdInput.style.display = 'inline-block';
                return;
            }
            
            const roomToJoin = roomIdInput.value.trim();
            if (!roomToJoin) {
                alert('Please enter a room ID');
                return;
            }
            
            playerName = playerNameInput.value || "Player";
            setupPeerConnection();
            
            // Set up a timeout to detect connection failures
            let connectionTimeout;
            
            peer.on('open', (id) => {
                // Only try to connect once peer is fully initialized
                clearTimeout(connectionTimeout);
                
                // Connect to host (assume host's peer ID is the same as room ID for simplicity)
                const conn = peer.connect(roomToJoin, {
                    reliable: true
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    alert('Failed to connect to room ' + roomToJoin + '. Make sure the room ID is correct and the host is online.');
                });
                
                handleConnection(conn);
                
                // Update UI
                hostButton.disabled = true;
                joinButton.disabled = true;
                roomIdInput.disabled = true;
                playerNameInput.disabled = true;
                
                // Set a 10-second timeout for connection
                connectionTimeout = setTimeout(() => {
                    if (!conn.open) {
                        alert('Connection timed out. Make sure the room ID is correct and try again.');
                        
                        // Reset UI to allow trying again
                        hostButton.disabled = false;
                        joinButton.disabled = false;
                        roomIdInput.disabled = false;
                        playerNameInput.disabled = false;
                    }
                }, 10000);
            });
        }
        
        // Handle a new peer connection
        function handleConnection(conn) {
            // Store connection
            connections.push(conn);
            
            conn.on('open', () => {
                console.log('Connected to peer: ' + conn.peer);
                
                // Send player info to new peer
                conn.send({
                    type: 'player-info',
                    id: playerId,
                    name: playerName,
                    position: {
                        x: localPlayer.position.x,
                        y: localPlayer.position.y,
                        z: localPlayer.position.z
                    },
                    rotation: {
                        y: localPlayer.rotation.y
                    }
                });
                
                // If we're the host, send the room ID and player list
                if (roomId) {
                    conn.send({
                        type: 'room-info',
                        roomId: roomId,
                        players: getPlayerList()
                    });
                }
                
                // Update player count
                updatePlayerCount();
            });
            
            conn.on('data', (data) => {
                handlePeerData(conn.peer, data);
            });
            
            conn.on('close', () => {
                console.log('Connection closed to peer: ' + conn.peer);
                
                // Remove player from scene
                if (players[conn.peer]) {
                    scene.remove(players[conn.peer]);
                    delete players[conn.peer];
                }
                
                // Remove connection
                connections = connections.filter(c => c.peer !== conn.peer);
                
                // Update player count
                updatePlayerCount();
                
                // Remove from player list
                const playerElement = document.getElementById('player-' + conn.peer);
                if (playerElement) {
                    playerElement.remove();
                }
            });
        }
        
        // Handle data received from peers
        function handlePeerData(peerId, data) {
            switch (data.type) {
                case 'player-info':
                    // Add or update player in the scene
                    addOrUpdatePlayer(data);
                    break;
                    
                case 'position-update':
                    // Update player position
                    if (players[peerId]) {
                        players[peerId].position.set(
                            data.position.x,
                            data.position.y,
                            data.position.z
                        );
                        players[peerId].rotation.y = data.rotation.y;
                    }
                    break;
                    
                case 'room-info':
                    // Store room info
                    roomId = data.roomId;
                    
                    // Update UI
                    roomInfo.style.display = 'block';
                    currentRoomIdSpan.textContent = roomId;
                    
                    // Update player list
                    if (data.players) {
                        data.players.forEach(player => {
                            updatePlayerList(player);
                        });
                    }
                    break;
            }
        }
        
        // Add or update a player in the scene
        function addOrUpdatePlayer(data) {
            // If player already exists, update position
            if (players[data.id]) {
                players[data.id].position.set(
                    data.position.x,
                    data.position.y,
                    data.position.z
                );
                players[data.id].rotation.y = data.rotation.y;
                return;
            }
            
            // Create new player mesh
            const settings = qualitySettings[currentQuality];
            const geometry = new THREE.BoxGeometry(1, 1, 1); // Cube instead of sphere
            const colorIndex = Object.keys(players).length % playerColors.length + 1;
            const material = new THREE.MeshStandardMaterial({ 
                color: playerColors[colorIndex],
                flatShading: currentQuality === 'low'
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(
                data.position.x,
                data.position.y,
                data.position.z
            );
            playerMesh.rotation.y = data.rotation.y;
            playerMesh.userData = { name: data.name };
            
            if (settings.shadowsEnabled) {
                playerMesh.castShadow = true;
            }
            
            scene.add(playerMesh);
            players[data.id] = playerMesh;
            
            // Create player label
            createPlayerLabel(playerMesh, data.name);
            
            // Update player list UI
            updatePlayerList({
                id: data.id,
                name: data.name
            });
        }
        
        // Send position update to all peers
        function sendPositionUpdate() {
            if (!connections.length) return;
            
            const update = {
                type: 'position-update',
                position: {
                    x: localPlayer.position.x,
                    y: localPlayer.position.y,
                    z: localPlayer.position.z
                },
                rotation: {
                    y: localPlayer.rotation.y
                }
            };
            
            connections.forEach(conn => {
                if (conn.open) {
                    conn.send(update);
                }
            });
        }
        
        // Update player count UI
        function updatePlayerCount() {
            const count = 1 + Object.keys(players).length; // 1 for local player
            playerCountSpan.textContent = count;
        }
        
        // Get list of all players
        function getPlayerList() {
            const list = [{
                id: playerId,
                name: playerName,
                host: !!roomId
            }];
            
            connections.forEach(conn => {
                const playerElement = document.getElementById('player-' + conn.peer);
                if (playerElement) {
                    const name = playerElement.textContent.split(': ')[1];
                    list.push({
                        id: conn.peer,
                        name: name
                    });
                }
            });
            
            return list;
        }
        
        // Update player list UI
        function updatePlayerList(player) {
            // Check if player already exists in list
            let playerElement = document.getElementById('player-' + player.id);
            
            if (!playerElement) {
                playerElement = document.createElement('div');
                playerElement.id = 'player-' + player.id;
                playerListDiv.appendChild(playerElement);
            }
            
            playerElement.textContent = (player.host ? 'ðŸ‘‘ ' : '') + 'Player: ' + player.name;
        }
        
        // Set up button event listeners
        const hostButton = document.getElementById('hostGame');
        const joinButton = document.getElementById('joinGame');
        const roomIdInput = document.getElementById('roomId');
        const playerNameInput = document.getElementById('playerName');
        const roomInfo = document.getElementById('roomInfo');
        const currentRoomIdSpan = document.getElementById('currentRoomId');
        const playerCountSpan = document.getElementById('playerCount');
        const playerListDiv = document.getElementById('playerList');
        
        // Update player name label when typing in the name field
        playerNameInput.addEventListener('input', function() {
            playerName = this.value || "You";
            
            // If local player exists, update its label
            if (localPlayer) {
                // Remove existing label
                for (let i = localPlayer.children.length - 1; i >= 0; i--) {
                    if (localPlayer.children[i] instanceof THREE.Sprite) {
                        localPlayer.remove(localPlayer.children[i]);
                    }
                }
                
                // Create a new label with updated name
                createPlayerLabel(localPlayer, playerName);
            }
        });
        
        hostButton.addEventListener('click', hostGame);
        joinButton.addEventListener('click', joinGame);
        
        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
